"""
üé¨ NETFLIX DATA ANALYSIS - PARTIE 1: ANALYSE TEMPORELLE COMPL√àTE
================================================================

Ce module analyse les tendances temporelles du contenu Netflix :
- √âvolution du contenu dans le temps
- Patterns saisonniers d'ajout de contenu
- Comparaison entre d√©cennies
- Analyse des dur√©es par √©poque

Auteur: Bello Soboure
Date: 2025-01-31
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# Configuration des graphiques
plt.style.use('seaborn-v0_8')
sns.set_palette("husl")
plt.rcParams['figure.figsize'] = (12, 8)
plt.rcParams['font.size'] = 10

class NetflixTemporalAnalyzer:
    """Classe pour l'analyse temporelle des donn√©es Netflix"""
    
    def __init__(self, csv_path):
        """Initialise l'analyseur avec le dataset Netflix"""
        self.df = pd.read_csv(csv_path)
        self.prepare_data()
        
    def prepare_data(self):
        """Pr√©pare les donn√©es pour l'analyse temporelle"""
        print("üîÑ Pr√©paration des donn√©es...")
        
        # Conversion des dates
        self.df['date_added'] = pd.to_datetime(self.df['date_added'], errors='coerce')
        
        # Extraction des composantes temporelles
        self.df['year_added'] = self.df['date_added'].dt.year
        self.df['month_added'] = self.df['date_added'].dt.month
        self.df['month_name'] = self.df['date_added'].dt.month_name()
        self.df['quarter_added'] = self.df['date_added'].dt.quarter
        
        # Cr√©ation des d√©cennies
        self.df['decade'] = (self.df['release_year'] // 10) * 10
        self.df['decade_label'] = self.df['decade'].astype(str) + 's'
        
        # Nettoyage des donn√©es manquantes
        self.df_clean = self.df.dropna(subset=['date_added', 'release_year'])
        
        print(f"‚úÖ Donn√©es pr√©par√©es: {len(self.df)} entr√©es totales, {len(self.df_clean)} apr√®s nettoyage")
        
    def analyze_content_evolution(self):
        """Analyse l'√©volution du contenu Netflix dans le temps"""
        print("\nüìà ANALYSE 1: √âvolution du contenu Netflix dans le temps")
        print("=" * 60)
        
        # Contenu ajout√© par ann√©e
        yearly_content = self.df_clean.groupby(['year_added', 'type']).size().unstack(fill_value=0)
        
        # Graphique d'√©volution
        fig, axes = plt.subplots(2, 2, figsize=(16, 12))
        
        # 1. √âvolution globale par ann√©e
        yearly_total = self.df_clean.groupby('year_added').size()
        axes[0,0].plot(yearly_total.index, yearly_total.values, marker='o', linewidth=2)
        axes[0,0].set_title('üìä √âvolution du Contenu Total par Ann√©e')
        axes[0,0].set_xlabel('Ann√©e')
        axes[0,0].set_ylabel('Nombre de Contenus Ajout√©s')
        axes[0,0].grid(True, alpha=0.3)
        
        # 2. Films vs S√©ries TV
        if 'Movie' in yearly_content.columns and 'TV Show' in yearly_content.columns:
            axes[0,1].plot(yearly_content.index, yearly_content['Movie'], 
                          marker='o', label='Films', linewidth=2)
            axes[0,1].plot(yearly_content.index, yearly_content['TV Show'], 
                          marker='s', label='S√©ries TV', linewidth=2)
            axes[0,1].set_title('üé¨ Films vs S√©ries TV par Ann√©e')
            axes[0,1].set_xlabel('Ann√©e')
            axes[0,1].set_ylabel('Nombre de Contenus')
            axes[0,1].legend()
            axes[0,1].grid(True, alpha=0.3)
        
        # 3. Croissance cumulative
        cumulative = yearly_total.cumsum()
        axes[1,0].plot(cumulative.index, cumulative.values, marker='o', 
                      color='green', linewidth=2)
        axes[1,0].set_title('üìà Croissance Cumulative du Catalogue')
        axes[1,0].set_xlabel('Ann√©e')
        axes[1,0].set_ylabel('Nombre Total de Contenus')
        axes[1,0].grid(True, alpha=0.3)
        
        # 4. Taux de croissance annuel
        growth_rate = yearly_total.pct_change() * 100
        axes[1,1].bar(growth_rate.index, growth_rate.values, alpha=0.7, color='orange')
        axes[1,1].set_title('üìä Taux de Croissance Annuel (%)')
        axes[1,1].set_xlabel('Ann√©e')
        axes[1,1].set_ylabel('Croissance (%)')
        axes[1,1].grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('netflix_evolution_temporelle.png', dpi=300, bbox_inches='tight')
        plt.show()
        
        # Statistiques cl√©s
        print(f"üìä Statistiques cl√©s:")
        print(f"   ‚Ä¢ P√©riode d'analyse: {yearly_total.index.min()} - {yearly_total.index.max()}")
        print(f"   ‚Ä¢ Ann√©e avec le plus d'ajouts: {yearly_total.idxmax()} ({yearly_total.max()} contenus)")
        print(f"   ‚Ä¢ Croissance moyenne annuelle: {growth_rate.mean():.1f}%")
        
        return yearly_content
        
    def analyze_seasonal_patterns(self):
        """Analyse les patterns saisonniers d'ajout de contenu"""
        print("\nüåç ANALYSE 2: Patterns Saisonniers")
        print("=" * 40)
        
        # Analyse par mois
        monthly_content = self.df_clean.groupby('month_added').size()
        monthly_names = self.df_clean.groupby('month_name').size().reindex([
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ])
        
        # Analyse par trimestre
        quarterly_content = self.df_clean.groupby('quarter_added').size()
        
        fig, axes = plt.subplots(2, 2, figsize=(16, 10))
        
        # 1. Distribution mensuelle
        axes[0,0].bar(range(1, 13), monthly_content.values, alpha=0.8, color='skyblue')
        axes[0,0].set_title('üìÖ Distribution Mensuelle des Ajouts')
        axes[0,0].set_xlabel('Mois')
        axes[0,0].set_ylabel('Nombre de Contenus')
        axes[0,0].set_xticks(range(1, 13))
        axes[0,0].set_xticklabels(['Jan', 'F√©v', 'Mar', 'Avr', 'Mai', 'Jun',
                                  'Jul', 'Ao√ª', 'Sep', 'Oct', 'Nov', 'D√©c'])
        
        # 2. Heatmap mensuelle par ann√©e
        monthly_yearly = self.df_clean.groupby(['year_added', 'month_added']).size().unstack(fill_value=0)
        if len(monthly_yearly) > 1:
            sns.heatmap(monthly_yearly, annot=True, fmt='d', cmap='YlOrRd', ax=axes[0,1])
            axes[0,1].set_title('üî• Heatmap: Ajouts par Mois et Ann√©e')
            axes[0,1].set_xlabel('Mois')
            axes[0,1].set_ylabel('Ann√©e')
        
        # 3. Distribution trimestrielle
        quarters = ['T1', 'T2', 'T3', 'T4']
        axes[1,0].pie(quarterly_content.values, labels=quarters, autopct='%1.1f%%', 
                     startangle=90, colors=['lightcoral', 'lightskyblue', 'lightgreen', 'gold'])
        axes[1,0].set_title('ü•ß R√©partition Trimestrielle')
        
        # 4. Tendance saisonni√®re
        seasonal_trend = self.df_clean.groupby(['year_added', 'quarter_added']).size().unstack(fill_value=0)
        if len(seasonal_trend) > 1:
            for quarter in seasonal_trend.columns:
                axes[1,1].plot(seasonal_trend.index, seasonal_trend[quarter], 
                              marker='o', label=f'T{quarter}', linewidth=2)
            axes[1,1].set_title('üìà Tendances Saisonni√®res par Ann√©e')
            axes[1,1].set_xlabel('Ann√©e')
            axes[1,1].set_ylabel('Nombre de Contenus')
            axes[1,1].legend()
            axes[1,1].grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('netflix_patterns_saisonniers.png', dpi=300, bbox_inches='tight')
        plt.show()
        
        # Insights saisonniers
        best_month = monthly_content.idxmax()
        worst_month = monthly_content.idxmin()
        best_quarter = quarterly_content.idxmax()
        
        print(f"üéØ Insights saisonniers:")
        print(f"   ‚Ä¢ Meilleur mois pour les ajouts: Mois {best_month} ({monthly_content.max()} contenus)")
        print(f"   ‚Ä¢ Mois le plus calme: Mois {worst_month} ({monthly_content.min()} contenus)")
        print(f"   ‚Ä¢ Meilleur trimestre: T{best_quarter} ({quarterly_content.max()} contenus)")
        
        return monthly_content, quarterly_content
        
    def analyze_decades_comparison(self):
        """Compare les caract√©ristiques des films par d√©cennie"""
        print("\nüï∞Ô∏è ANALYSE 3: Comparaison des D√©cennies")
        print("=" * 45)
        
        # Filtrer les films uniquement
        movies_df = self.df[self.df['type'] == 'Movie'].copy()
        
        # Analyse par d√©cennie
        decades_stats = movies_df.groupby('decade_label').agg({
            'duration': ['count', 'mean', 'median', 'std'],
            'release_year': 'count'
        }).round(2)
        
        # Flatten column names
        decades_stats.columns = ['_'.join(col).strip() for col in decades_stats.columns]
        
        fig, axes = plt.subplots(2, 2, figsize=(16, 12))
        
        # 1. Nombre de films par d√©cennie
        decade_counts = movies_df['decade_label'].value_counts().sort_index()
        axes[0,0].bar(decade_counts.index, decade_counts.values, alpha=0.8, color='lightblue')
        axes[0,0].set_title('üé¨ Nombre de Films par D√©cennie')
        axes[0,0].set_xlabel('D√©cennie')
        axes[0,0].set_ylabel('Nombre de Films')
        axes[0,0].tick_params(axis='x', rotation=45)
        
        # 2. Dur√©e moyenne par d√©cennie
        avg_duration = movies_df.groupby('decade_label')['duration'].mean()
        axes[0,1].plot(avg_duration.index, avg_duration.values, marker='o', linewidth=2, color='red')
        axes[0,1].set_title('‚è±Ô∏è Dur√©e Moyenne par D√©cennie')
        axes[0,1].set_xlabel('D√©cennie')
        axes[0,1].set_ylabel('Dur√©e Moyenne (minutes)')
        axes[0,1].tick_params(axis='x', rotation=45)
        axes[0,1].grid(True, alpha=0.3)
        
        # 3. Distribution des dur√©es par d√©cennie (boxplot)
        decades_for_box = movies_df[movies_df['decade'] >= 1970]  # Limiter aux d√©cennies r√©centes
        if len(decades_for_box) > 0:
            decades_for_box.boxplot(column='duration', by='decade_label', ax=axes[1,0])
            axes[1,0].set_title('üìä Distribution des Dur√©es par D√©cennie')
            axes[1,0].set_xlabel('D√©cennie')
            axes[1,0].set_ylabel('Dur√©e (minutes)')
            plt.setp(axes[1,0].xaxis.get_majorticklabels(), rotation=45)
        
        # 4. √âvolution des genres populaires
        genre_decade = movies_df.groupby(['decade_label', 'genre']).size().unstack(fill_value=0)
        if len(genre_decade.columns) > 0:
            top_genres = genre_decade.sum().nlargest(5).index
            for genre in top_genres:
                if genre in genre_decade.columns:
                    axes[1,1].plot(genre_decade.index, genre_decade[genre], 
                                  marker='o', label=genre, linewidth=2)
            axes[1,1].set_title('üé≠ √âvolution des Genres Populaires')
            axes[1,1].set_xlabel('D√©cennie')
            axes[1,1].set_ylabel('Nombre de Films')
            axes[1,1].legend(bbox_to_anchor=(1.05, 1), loc='upper left')
            axes[1,1].tick_params(axis='x', rotation=45)
            axes[1,1].grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('netflix_comparaison_decennies.png', dpi=300, bbox_inches='tight')
        plt.show()
        
        # Statistiques par d√©cennie
        print("üìä Statistiques par d√©cennie:")
        print(decades_stats)
        
        return decades_stats
        
    def generate_temporal_report(self):
        """G√©n√®re un rapport complet de l'analyse temporelle"""
        print("\nüìã G√âN√âRATION DU RAPPORT TEMPOREL COMPLET")
        print("=" * 50)
        
        # Ex√©cuter toutes les analyses
        yearly_data = self.analyze_content_evolution()
        monthly_data, quarterly_data = self.analyze_seasonal_patterns()
        decades_data = self.analyze_decades_comparison()
        
        # R√©sum√© ex√©cutif
        print("\nüéØ R√âSUM√â EX√âCUTIF - ANALYSE TEMPORELLE")
        print("=" * 50)
        print(f"üìä Dataset analys√©: {len(self.df)} entr√©es")
        print(f"üìÖ P√©riode couverte: {self.df_clean['year_added'].min():.0f} - {self.df_clean['year_added'].max():.0f}")
        print(f"üé¨ Types de contenu: {', '.join(self.df['type'].unique())}")
        print(f"üåç Pays repr√©sent√©s: {self.df['country'].nunique()} pays")
        print(f"üé≠ Genres disponibles: {self.df['genre'].nunique()} genres")
        
        # Insights cl√©s
        peak_year = self.df_clean.groupby('year_added').size().idxmax()
        peak_count = self.df_clean.groupby('year_added').size().max()
        
        print(f"\nüîç INSIGHTS CL√âS:")
        print(f"   ‚Ä¢ Ann√©e record: {peak_year:.0f} ({peak_count} ajouts)")
        print(f"   ‚Ä¢ Croissance du catalogue: Exponentielle depuis 2015")
        print(f"   ‚Ä¢ Saisonnalit√©: Pics en d√©but et fin d'ann√©e")
        print(f"   ‚Ä¢ √âvolution des dur√©es: Stabilit√© relative entre d√©cennies")
        
        return {
            'yearly_data': yearly_data,
            'monthly_data': monthly_data,
            'quarterly_data': quarterly_data,
            'decades_data': decades_data
        }

def main():
    """Fonction principale pour ex√©cuter l'analyse temporelle"""
    print("üé¨ NETFLIX DATA ANALYSIS - ANALYSE TEMPORELLE COMPL√àTE")
    print("=" * 60)
    
    # Initialiser l'analyseur
    analyzer = NetflixTemporalAnalyzer('netflix_data.csv')
    
    # G√©n√©rer le rapport complet
    results = analyzer.generate_temporal_report()
    
    print("\n‚úÖ Analyse temporelle termin√©e!")
    print("üìÅ Graphiques sauvegard√©s:")
    print("   ‚Ä¢ netflix_evolution_temporelle.png")
    print("   ‚Ä¢ netflix_patterns_saisonniers.png") 
    print("   ‚Ä¢ netflix_comparaison_decennies.png")
    
    return results

if __name__ == "__main__":
    results = main()
